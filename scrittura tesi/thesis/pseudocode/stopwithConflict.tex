\documentclass[class=article, crop=false]{standalone}
\usepackage[subpreambles=true]{standalone}
\usepackage{import}
\usepackage{blindtext}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amssymb,amsmath,amsthm}



\begin{document}
% Attenzione, pseudopolinomiale

We have pre-calculated the order in which the flight arrive in each node $x\in V$, and we say that, if there is a conflict, then $x_{i,j}=0$ means that $x_{j,i}=1$ and then that the flight $i$ pass before flight $i$,
if there are no conflict $x_{i,j}=x_{j,i}=1$
\begin{algorithm}
\caption{propagate time, stop each time you find a conflict}\label{alg:propalgo}
\begin{algorithmic}
\REQUIRE{graph $G=(V,E)$, set of flight $F$, path of each flight $P_i\forall i\in F$,  conflict variable $x_{i,j}$ (see above), $t(s,i)\forall i\in F, \forall s(P_i)$ starting time for the initial node of the path}
\ENSURE{earliest time an arc can come to a node $v\in V$}

\COMMENT{calculate the number number of conflict between two flights}
\STATE $Mc\gets 0$
\FORALL{$i \in F$}
    \FORALL{$j \in F$}
        \STATE $tmp\gets |P_i\cap P_j|$
        \IF{$tmp> Mc$}
            \STATE $Mc\gets tmp$
        \ENDIF
    \ENDFOR
\ENDFOR

\COMMENT{define t}
\FORALL{$i \in F$}
    \FORALL{$x\in V: x\notin s(P_i)$} % si intende che non è un nodo iniziale, per il quale dovrebbe essere dato
        \STATE $t(x,i)=-1$
    \ENDFOR
\ENDFOR

\COMMENT{propagation of time}
\FOR{$|F|^{Mc}$}
    \FORALL{$i\in F$}
        \FOR{$(x,y) \in P_i$}
            \IF{$\exists j\in F: y_{i,j}=0$}
                \IF{$t(y,j)=-1$}
                    \STATE\textbf{break}
                \ELSE
                    \STATE propagate time s.t. it's far enough from the conflict \COMMENT{}
                \ENDIF
            \ELSE
                \STATE propagate time %to be defined
                \COMMENT{$t(y,i)\gets t(x,i) + \frac d{v_{\min}}$} %da migliorare
            \ENDIF
        \ENDFOR
    \ENDFOR
\ENDFOR

\end{algorithmic}
\end{algorithm}


TODO: check if the next function it's working, with $d$ the distance, $s$ the maximum percentage change, $v_{i,j,z}$ the speed of the arc $(i,j)\in A$ and flight $z$, $D$ the safety distance ($\underline t,\overline t$ are the min and max safaty time)

$$
\forall i \in F,\forall (x,y)\in A\\\newline

\overline t_{i,y}=\begin{cases}
\overline t_{i,x}+\dots\frac d {\max\{\underline v_{i,y}, (1-s)*v_{x,y,i}\}} 
&\text{ if } \nexists j\in F : y_{i,j}\neq 1\\
\underline t_{j,y}+\dots%\frac D{\max\{\overline v_{j,y},  1+ v_{prec_j(x),x,z}\}}
&\text{ if } \exists j\in F : y_{i,j}= 1
\end{cases}


\underline t_{i,y}=\begin{cases}
\underline t_{i,x}+\frac d {\min\{\overline v_{i,y}, (1+s)*v_{x,y,i}\}} &\text{ if } \nexists j\in F : y_{i,j}\neq 1\\
\overline t_{j,y}+\dots%\frac D{\min\{\underline v_{j,y},  1- v_{prec_j(x),x,z}\}}
&\text{ if } \exists j\in F : y_{i,j}= 1
\end{cases}


$$

Possibili migliorie da inserire:\\
Per ogni volo, mettere in un buffer l'arco/l'ultimo nodo definito\\ 
Idee propagazione:\\
usare range permesso, quindi impostare nei nodi di conflitto le velocità e trattare negli altri posti tramite propagazione raggiungere gli altri, per i successivi non è un problema dato che dobbiamo attendere quelli che vengono prima.

For latest time, just use inverse the order of the path and some other small differences.
\end{document}