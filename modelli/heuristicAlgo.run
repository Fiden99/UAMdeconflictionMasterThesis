reset;
option solver gurobi;
option gurobi_options 'timing=1 outlev=1 threads=1 timelim=3600';
param data_name symbolic;
let data_name :=sprintf("%s/data/%s.dat",($absPath),($datFile));
param model_name symbolic;
let model_name :=sprintf("%s/multiComodity.mod",($absPath));
model (model_name);
data (data_name);
param iterations;
let iterations:=0;
param alpha;
let alpha:=4;
param found default 0;
param starting_time:=time();
param sol_name symbolic;
let sol_name := sprintf("%s/heuristicOut/%d%s.sol", ($absPath),($value),($datFile));
# Define the name of the file where the log of the solver will be saved
param log_name symbolic;
let log_name := sprintf("%s/heuristicOut/%d%s.log",($absPath),($value),($datFile));


repeat
{
	solve MC >(log_name);
	printf "find path\n";
	display w;
	fix {f in F, i in V,j in V: (i,j)in E} w[i,j,f];
	printf "fixed\n";
	solve UAM > (log_name);
	printf "solved conflicts\n";
	display w;
	if solve_result == "solved" then
	{
		let found:=1;
		printf "solution found";
	}
	else
	{
		for { f1 in F, f2 in F, i in V, j in V: (i,j) in E and f1 <> f2 } 
		{
			  if (w[i,j,f1] + w[i,j,f2] == 2) then 
			  {
			  #c'Ã¨ un conflitto, ma non sono sicuro che sia quello interessato
			    printf "conflict between flights %d %d in arc (%d,%d)\n", f1, f2, i, j;
			    let d[i,j] := min(sqrt(alpha) * d[i,j],1e5);
			  }
		}
	}
	let iterations:=iterations + 1;
	unfix{ i in V, j in V,f in F: (i,j) in E} w[i,j,f];
	display d;
}
while (found==0);
display iterations, starting_time-time(),UAM, w, t_ear;

# Store the solution in a file
printf "### total_solve_time = %f\n\n",starting_time-time() > (sol_name);
printf "\t\t variable\t value\t UB\t LB"
for {j in 1.._nvars} {
   printf "let %s :=\t %.20f\t %.20f\t %.20f;\n", _varname[j], _var[j] , _var[j].ub, _var[j].lb > (sol_name);
}
