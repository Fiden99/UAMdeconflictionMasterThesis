reset;
option solver gurobi;
option gurobi_options 'timing=1 outlev=1 threads=1 timelim=21600';
param data_name symbolic;
let data_name :=sprintf("%s/data/%s.dat",($absPath),($datFile));
param model_name symbolic;
let model_name :=sprintf("%s/multiComodity.mod",($absPath));
model (model_name);
data (data_name);
param iterations;
let iterations:=0;
param alpha;
let alpha:=4;
param found default 0;
param sol_name symbolic;
let sol_name := sprintf("%s/heuristicOut/%s%s.sol", ($absPath),($value),($datFile));
# Define the name of the file where the log of the solver will be saved
param log_name symbolic;
let log_name := sprintf("%s/heuristicOut/%s%s.log",($absPath),($value),($datFile));
display data_name;

repeat
{
	option relax_integrality 1;
	solve path >(log_name);
	if solve_result <> "solved" then
	{
		printf "path not found in given time";
		break;
	}
	printf "find path in it %d\nsolve time:= %f, ampl time:= %f, sol:=%d",iterations,_solve_time,_ampl_time,MC >(sol_name);
	#to put a check if I found a path or not, if I couldn't find it's useless continue
	fix {f in F, i in V,j in V: (i,j)in E} w[i,j,f];
	option relax_integrality 0;
	solve conflicts > (log_name);
	printf "find time in it %d\nsolve time:= %f, ampl time:= %f, sol:=%d",iterations,_solve_time,_ampl_time,UAM >(sol_name);
	if solve_result == "solved" then
	{
		let found:=1;
	}
	else
	{
		for { f1 in F, f2 in F, i in V, j in V: (i,j) in E and f1 <> f2 } 
		{
			  if (w[i,j,f1] + w[i,j,f2] == 2) then 
			  {
			  let d[i,j] := min(sqrt(alpha) * d[i,j],1e5);
			  }
		}
	}
	let iterations:=iterations + 1;
	unfix{ i in V, j in V,f in F: (i,j) in E} w[i,j,f];
}
while (found==0);

# Store the solution in a file
printf "### total_solve_time = %f\n\n",(_ampl_elapsed_time + _total_solve_elapsed_time) > (sol_name);
display UAM >(sol_name);
printf "variable\t\t value\t UB\t\t\t LB\n" >(sol_name);
for { j in 1.._nvars} {
   printf "let %s :=\t %d\t %f\t %f;\n", _varname[j], _var[j] , _var[j].ub, _var[j].lb > (sol_name);
}

