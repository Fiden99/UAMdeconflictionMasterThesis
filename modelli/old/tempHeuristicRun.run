reset;
#to evaluate 
option presolve 0;
#option show_stats 1;
option solver gurobi;
option gurobi_options 'timing=1 outlev=1 threads=1 MIPFocus=1 timelim=600 mipstart=2' ;
model testMultiComodityChangePathProblem.mod;
data data/nn5nf100/grid0.dat;
let {x in V,(x,x1) in E, (x2,x) in E : x1==x2} anglePM[x,x1,x2]:=1;
for {f in F,(i,j) in E}
	let dMCF[f,i,j]:= d[i,j];
param obtainedSol default 0;
param alpha default 4;
param opt default Infinity;
param lastOpt default Infinity;
param sameOpt default 0;
param found default 0;
param tempNode default Infinity;
param iterations default 0;
param t_hat_ear_backup{F,V} default Infinity;
param t_hat_lat_backup{F,V} default Infinity;
repeat
{
	solve path;
    #solve minCon >(log_name);
	if solve_result <> "solved" then
	{
		printf "path not found in given time\n";
        display solve_result, solve_result_num;
		break;
	}
    
    printf("fixing w\n");
	
	let {(i,j) in E, f in F} w[i,j,f]:=wPath[i,j,f];
	let {(f,x)in FV} t_hat_ear_backup[f,x]:=t_hat_ear[f,x];
	let {(f,x)in FV} t_hat_lat_backup[f,x]:=t_hat_lat[f,x];
	for {f in F}
	{
		let tempNode := s[f];
		repeat while (tempNode <> e[f])
		{
			for {(tempNode,i) in E : w[tempNode,i,f] == 1}
			{
				let t_hat_ear[f,i]:=t_hat_ear[f,tempNode] + d[tempNode,i]/v_min[f,tempNode,i];
				let t_hat_lat[f,i]:=t_hat_ear[f,i] + 2;
				let tempNode:=i;
				break;
			}
		}
	}

    #solving with fixed variables
	#display t_hat_ear, t_hat_lat;
	solve conflicts;
	let {(f,x)in FV} t_hat_ear[f,x]:=t_hat_ear_backup[f,x];
	let {(f,x)in FV} t_hat_lat[f,x]:=t_hat_lat_backup[f,x];
	display solve_result, solve_result_num;
	if (solve_result == "solved" or (400<=solve_result_num and solve_result_num<=405)) then
	{
		let obtainedSol:=1;
        printf "solved conflicts\n";
        #update optimal solution
		if (opt > UAM) then
		{
			let opt:=UAM;
		}
	}
    else
    {
        printf "conflicts not solved\n, exit";
        break;
    }
    #if (solve_result =="solved") then
	#if (solve_result == "solved" or iterations>100) then
	if (solve_result == "solved" or sameOpt>=2 or iterations>=0) then
	{
		let found:=1;
	}
	else 	
	{
		#TODO da correggere
		for { f1 in F, f2 in F,x in V: f1 <> f2 and (f1,x) in FV and (f2,x) in FV }
		#for {f1 in F; f2 in F, x in V, y in V, z in V: ((x,y) in E or (y,x) in E) and ((x,z) in E or (z,x) in E) and f1<>f2} 
		{
			#trail
			#if (f1,f2,x) in (setof{(fl1,fl2,a,b) in trail} (fl1,fl2,a)) then
			for {(fl1,fl2,a,b) in trail1 : a==x and fl1==f1 and fl2==f2 and (trail13[f1,f2,a,b].slack == 0 or trail14[f1,f2,a,b].slack==0)}
			{
				let dMCF[fl1,a,b] := min(sqrt(alpha) * dMCF[fl1,a,b],1e5);
				let dMCF[fl2,a,b] := min(sqrt(alpha) * dMCF[fl2,a,b],1e5);
			}
			#else if (f1,f2,x) in (setof{(fl1,fl2,a,b) in trail} (fl1,fl2,b)) then
			#TODO da capire se va bene cos√¨ o va lavorata meglio
			for {(fl1,fl2,a,b) in trail2 : b==x and fl1==f1 and fl2==f2 and (trail23[f1,f2,a,b].slack==0 or trail24[f1,f2,a,b].slack==0)}
			{
				let dMCF[fl1,a,b] := min(sqrt(alpha) * dMCF[fl1,a,b],1e5);
				let dMCF[fl2,a,b] := min(sqrt(alpha) * dMCF[fl2,a,b],1e5);
			}
			#else if (f1,f2,x) in (setof{(fl1,fl2,a,b,c) in merge} (fl1,fl2,a)) then
			for {(fl1,fl2,a,b,c) in merge : a==x and fl1==f1 and fl2==f2 and (merge3[f1,f2,a,b,c].slack==0 or merge4[f1,f2,a,b,c].slack==0)}
			{
				let dMCF[fl1,b,a] := min(sqrt(alpha) * dMCF[fl1,b,a],1e5);
				let dMCF[fl1,c,a] := min(sqrt(alpha) * dMCF[fl1,c,a],1e5);
				let dMCF[fl2,b,a] := min(sqrt(alpha) * dMCF[fl2,b,a],1e5);
				let dMCF[fl2,c,a] := min(sqrt(alpha) * dMCF[fl2,c,a],1e5);
			}
			#else if (f1,f2,x) in (setof{(fl1,fl2,a,b,c) in split} (fl1,fl2,a)) then
			for {(fl1,fl2,a,b,c) in split : a==x and fl1==f1 and fl2==f2 and (split3[f1,f2,a,b,c].slack==0 or split4[f1,f2,a,b,c].slack==0)}
			{
				let dMCF[fl1,a,b] := min(sqrt(alpha) * dMCF[fl1,a,b],1e5);
				let dMCF[fl1,a,c] := min(sqrt(alpha) * dMCF[fl1,a,c],1e5);
				let dMCF[fl2,a,b] := min(sqrt(alpha) * dMCF[fl2,a,b],1e5);
				let dMCF[fl2,a,c] := min(sqrt(alpha) * dMCF[fl2,a,c],1e5);
			}
			#else if (f1,f2,x) in (setof{(fl1,fl2,a,b,c) in diver1} (fl1,fl2,a)) then
			for {(fl1,fl2,a,b,c) in diver1 : a==x and fl1==f1 and fl2==f2 and (diver3[f1,f2,a,b,c].slack==0 or diver4[f1,f2,a,b,c].slack==0)}
			{
				let dMCF[fl1,a,b] := min(sqrt(alpha) * dMCF[fl1,a,b],1e5);
				let dMCF[fl1,c,a] := min(sqrt(alpha) * dMCF[fl1,c,a],1e5);
				let dMCF[fl2,a,b] := min(sqrt(alpha) * dMCF[fl2,a,b],1e5);
				let dMCF[fl2,c,a] := min(sqrt(alpha) * dMCF[fl2,c,a],1e5);
			}
			#else if (f1,f2,x) in (setof{(fl1,fl2,a,b,c) in diver2} (fl1,fl2,a)) then
			for {(fl1,fl2,a,b,c) in diver2 : a==x and fl1==f1 and fl2==f2 and (diver3_1[f1,f2,a,b,c].slack==0 or diver4_1[f1,f2,a,b,c].slack==0)}
			{
				let dMCF[fl1,b,a] := min(sqrt(alpha) * dMCF[fl1,b,a],1e5);
				let dMCF[fl1,c,a] := min(sqrt(alpha) * dMCF[fl1,c,a],1e5);
				let dMCF[fl2,b,a] := min(sqrt(alpha) * dMCF[fl2,b,a],1e5);
				let dMCF[fl2,c,a] := min(sqrt(alpha) * dMCF[fl2,c,a],1e5);
			}
		}
	}
    if (UAM == lastOpt) then
    {
        let sameOpt:=sameOpt+1;
    }
    else
    {
        let sameOpt:=0;
    }
	let iterations:=iterations + 1;
	display {(f,x,y) in F cross E : dMCF[f,x,y]<>d[x,y]} dMCF[f,x,y];
    let lastOpt:=UAM;
	#let cutoff:= cutoff- 0.1*opt;

}
while (found==0);
