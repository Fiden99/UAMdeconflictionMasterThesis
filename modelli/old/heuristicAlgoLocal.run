reset;
option solver gurobi;
option gurobi_options 'timing=1 outlev=1 timelim=21600';
#param data_name symbolic;
#let data_name :=sprintf("%s/data/%s.dat",($absPath),($datFile));
#param model_name symbolic;
#let model_name :=sprintf("%s/multiComodity.mod",($absPath));
model multiComodity.mod
data data/airport0.dat;
param iterations;
let iterations:=0;
param alpha;
let alpha:=4;
param found default 0;
param starting_time:=time();
param sol_name symbolic;
let sol_name := "heuristicOut/3airtport0.sol";
# Define the name of the file where the log of the solver will be saved
param log_name symbolic;
let log_name := "heuristicOut/3airport0.log";
for {i in V, j in V:(i,j) in E}
	let dMCF[i,j]:= d[i,j];
repeat
{
	option relax_integrality 1;
	solve path >(log_name);
	fix {f in F, i in V,j in V: (i,j)in E} w[i,j,f];
	option relax_integrality 0;
	printf "find path\n";
	display w;
	fix {f in F, i in V,j in V: (i,j)in E} w[i,j,f];
	printf "fixed\n";
	solve conflicts > (log_name);
	printf "solved conflicts\n";
	display w;
	if solve_result == "solved" then
	{
		let found:=1;
		printf "solution found\n";
	}
	else
	{
		for { f1 in F, f2 in F, i in V, j in V: (i,j) in E and f1 <> f2 } 
		{
			  if (w[i,j,f1] + w[i,j,f2] == 2) then 
			  {
			  #c'Ã¨ un conflitto, ma non sono sicuro che sia quello interessato
			    printf "conflict between flights %d %d in arc (%d,%d)\n", f1, f2, i, j;
			    let dMCF[i,j] := min(sqrt(alpha) * dMCF[i,j],1e5);
			  }
		}
	}
	let iterations:=iterations + 1;
	unfix{ i in V, j in V,f in F: (i,j) in E} w[i,j,f];
	display d;
}
while (found==0);
display iterations,UAM, w, t_ear;

# Store the solution in a file
printf "### total_solve_time = %f\n\n",(_ampl_elapsed_time + _total_solve_elapsed_time) > (sol_name);
display UAM >(sol_name);
printf "variable\t\t value\t UB\t\t\t LB\n" >(sol_name);
for { j in 1.._nvars} {
   printf "let %s :=\t %d\t %f\t %f;\n", _varname[j], _var[j] , _var[j].ub, _var[j].lb > (sol_name);
}
