reset;
option solver gurobi;
option gurobi_options 'timing=1 outlev=1 threads=1 timelim=60';
param data_name symbolic;
let data_name :=sprintf("%s/data/%s.dat",($absPath),($datFile));
#let data_name :=sprintf("%s/data/nn10nf100/%s.dat",($absPath),($datFile));
param model_name symbolic;
let model_name :=sprintf("%s/multiComodity.mod",($absPath));
model (model_name);
data (data_name);
param iterations;
let iterations:=0;
param alpha;
let alpha:=4;
param found default 0;
param sol_name symbolic;
let sol_name := sprintf("%s/heuristicOut/%s/%s%s.sol", ($absPath),($value),($value),($datFile));
#let sol_name := sprintf("%s/heuristicOut/nn10nf100/%s%s.sol", ($absPath),($value),($datFile));
# Define the name of the file where the log of the solver will be saved
param log_name symbolic;
let log_name := sprintf("%s/heuristicOut/%s/%s%s.log",($absPath),($value),($value),($datFile));
#let log_name := sprintf("%s/heuristicOut/nn10nf100/%s%s.log",($absPath),($value),($datFile));
display data_name;
for {i in V, j in V:(i,j) in E}
	let dMCF[i,j]:= d[i,j];

#heuristic var
param opt default Infinity;

param opt_z_up{i in V,j in V,F: (i,j) in E} default Infinity;
param opt_z_down{i in V,j in V,F: (i,j) in E}  default Infinity;	

param opt_t_down{F,V} default Infinity;
param opt_t_up{F,V} default Infinity;

param opt_t_ear{F,V} default Infinity;															
param opt_t_lat{F,V} default Infinity;		

param opt_y1t{i in F, j in F, x in V, y in V:(x,y) in E and i<>j} default Infinity;
param opt_y1o1{i in F, j in F, x in V, y in V:(x,y) in E and i<>j} default Infinity;
param opt_y1o2{i in F, j in F, x in V, y in V:(x,y) in E and i<>j} default Infinity;

param opt_y2t{i in F, j in F, x in V, y in V:(x,y) in E and i<>j} default Infinity;
param opt_y2o1{i in F, j in F, x in V, y in V:(x,y) in E and i<>j} default Infinity;
param opt_y2o2{i in F, j in F, x in V, y in V:(x,y) in E and i<>j} default Infinity;

param opt_ym{i in F, j in F, x in V, x1 in V, x2 in V: (x1,x) in E and (x2,x) in E and i<>j and x1<> x2} default Infinity;
param opt_ymo1{i in F, j in F, x in V, x1 in V, x2 in V: (x1,x) in E and (x2,x) in E and i<>j and x1<> x2} default Infinity;
param opt_ymo2{i in F, j in F, x in V, x1 in V, x2 in V: (x1,x) in E and (x2,x) in E and i<>j and x1<> x2} default Infinity;

param opt_yd{i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x2,x) in E and  i<>j and x1<> x2} default Infinity;
param opt_ydo1{i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x2,x) in E and  i<>j and x1<> x2} default Infinity;
param opt_ydo2{i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x2,x) in E and  i<>j and x1<> x2} default Infinity;

param opt_ys{i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x,x2) in E and  i<>j and x1<> x2} default Infinity;
param opt_yso1{i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x,x2) in E and  i<>j and x1<> x2} default Infinity;
param opt_yso2{i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x,x2) in E and  i<>j and x1<> x2} default Infinity;

param opt_w{i in V,j in V,F: (i,j) in E} default Infinity;		

param optTime default Infinity;
param iteropt default Infinity;
#param cutoff default Infinity;
repeat
{
	printf "solving path in it %d\n\n",iterations> (log_name);
	#capire perché inserisce troppe variablili
	solve path >(log_name);
	if solve_result <> "solved" then
	{
		printf "path not found in given time\n";
		break;
	}
	for {i in V,j in V,f in F: (i,j) in E}
		let w[i,j,f]:=wPath[i,j,f];

	let {i in F, j in F, x in V, y in V:(x,y) in E and i<>j} y1t[i,j,x,y]:=1;
	let {i in F, j in F, x in V, y in V:(x,y) in E and i<>j} y2t[i,j,x,y]:=1;
    for {i in F, j in F, x in V, y in V:(x,y) in E and i<>j and w[x,y,i]+ w[x,y,j] == 2}
	{
        let y1t[i,j,x,y]:=0;
        let y2t[i,j,x,y]:=0;
	}
	let {i in F, j in F, x in V, x1 in V, x2 in V : i<>j and x1<>x2 and (x1,x) in E and (x2,x) in E} ym[i,j,x,x1,x2]:=1;
	let {i in F, j in F, x in V, x1 in V, x2 in V : i<>j and x1<>x2 and (x,x1) in E and (x2,x) in E} yd[i,j,x,x1,x2]:=1;
	let {i in F, j in F, x in V, x1 in V, x2 in V : i<>j and x1<>x2 and (x,x1) in E and (x,x2) in E} ys[i,j,x,x1,x2]:=1;
	for {i in F, j in F, x in V, x1 in V, x2 in V : i<>j and x1<>x2}
	{
        if ((x1,x) in E and (x2,x) in E and w[x1,x,i]+ w[x2,x,j] == 2) then
			let ym[i,j,x,x1,x2]:=0;
        if ((x,x1) in E and (x2,x) in E and w[x,x1,i]+w[x2,x,j] == 2) then
            let yd[i,j,x,x1,x2]:=0;
        if ((x,x1) in E and (x,x2) in E and w[x,x1,i]+w[x,x2,j] ==2) then
            let ys[i,j,x,x1,x2]:=0;
	}	
	printf "find path in it %d\nsolve time:= %f, ampl time:= %f, sol:=%d",iterations,_solve_time,_ampl_time,MC >(sol_name);
	solve conflicts > (log_name);
	printf "find time in it %d\nsolve time:= %f, ampl time:= %f, sol:=%d",iterations,_solve_time,_ampl_time,UAM >(sol_name);
	#definire problema più compatto
	display solve_result, solve_result_num;
	#if (solve_result == "solved" or 400<=solve_result_num or solve_result_num<=403 ) then
	if (solve_result == "solved" or 400<=solve_result_num or solve_result_num<=403 ) then
	{
		if (opt > UAM) then
		{
			let opt:=UAM;
			let iteropt:=iterations;
			let optTime:=(_ampl_elapsed_time + _total_solve_elapsed_time);
			#let cutoff:=opt*2;
			for {f in F,i in V}
			{
				let opt_t_down[f,i]:= t_down[f,i];
				let opt_t_up[f,i]:= t_up[f,i];
				let opt_t_ear[f,i]:=t_ear[f,i];															
				let opt_t_lat[f,i]:= t_lat[f,i];															
			}
			for {i in V,j in V,f in F: (i,j) in E}
			{
				let opt_z_up[i,j,f]:= z_up[i,j,f];
				let opt_z_down[i,j,f]:= z_down[i,j,f];									
				let opt_w[i,j,f]:= w[i,j,f];
			}
			for {i in F, j in F, x in V, y in V:(x,y) in E and i<>j}
			{
				let opt_y1t[i,j,x,y]:=y1t[i,j,x,y];
				let opt_y1o1[i,j,x,y]:=y1o1[i,j,x,y];
				let opt_y1o2[i,j,x,y]:=y1o2[i,j,x,y];

				let opt_y2t[i,j,x,y]:=y2t[i,j,x,y];
				let opt_y2o1[i,j,x,y]:=y2o1[i,j,x,y];
				let opt_y2o2[i,j,x,y]:=y2o2[i,j,x,y];
			}
			for {i in F, j in F, x in V, x1 in V, x2 in V: (x1,x) in E and (x2,x) in E and i<>j and x1<> x2}
			{
				let opt_ym[i,j,x,x1,x2]:=ym[i,j,x,x1,x2];
				let opt_ymo1[i,j,x,x1,x2]:=ymo1[i,j,x,x1,x2];
				let opt_ymo2[i,j,x,x1,x2]:=ymo2[i,j,x,x1,x2];
			}
			for {i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x2,x) in E and  i<>j and x1<> x2}
			{
				let opt_yd[i,j,x,x1,x2]:=yd[i,j,x,x1,x2];
				let opt_ydo1[i,j,x,x1,x2]:=ydo1[i,j,x,x1,x2];
				let opt_ydo2[i,j,x,x1,x2]:=ydo2[i,j,x,x1,x2];
			}
			for {i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x,x2) in E and  i<>j and x1<> x2}
			{
				let opt_ys[i,j,x,x1,x2]:=ys[i,j,x,x1,x2];
				let opt_yso1[i,j,x,x1,x2]:=yso1[i,j,x,x1,x2];
				let opt_yso2[i,j,x,x1,x2]:=yso2[i,j,x,x1,x2];
			}
		}
	}
	if (solve_result == "solved" or iterations>100) then
	{
		let found:=1;
	}
	else 	
	{
		for { f1 in F, f2 in F, i in V, j in V: (i,j) in E and f1 <> f2 } 
		{
			  if (w[i,j,f1] + w[i,j,f2] == 2) then 
			  {
			  let dMCF[i,j] := min(sqrt(alpha) * dMCF[i,j],1e5);
			  }
		}
	}
	display dMCF;
	let iterations:=iterations + 1;
	#let cutoff:= cutoff- 0.1*opt;

}
while (found==0);

# Store the solution in a file
printf "### total_solve_time = %f\n\n",(_ampl_elapsed_time + _total_solve_elapsed_time) > (sol_name);
display opt, iterations, optTime,iteropt>(sol_name);
printf "variable\t\t value\n" >(sol_name);
for {i in V,j in V, f in F: (i,j) in E}{
	printf "w[%d,%d,%d] :=\t %d;\n", i,j,f, opt_w[i,j,f] > (sol_name);
}
for {i in V,f in F}
{
	printf"t_ear[%d,%d] :=\t%f;\n",opt_t_ear[f,i]> (sol_name);															
	printf"t_lat[%d,%d] :=\t%f;\n",opt_t_lat[f,i]> (sol_name);															
	printf"t_down[%d,%d] :=\t%f;\n", opt_t_down[f,i] > (sol_name);
	printf"t_up[%d,%d] :=\t%f;\n",opt_t_up[f,i]> (sol_name);
}
for {i in V,j in V, f in F: (i,j) in E}
{
	printf"z_up[%d,%d,%d] :=\t%f;\n",i,j,f,opt_z_up[i,j,f]> (sol_name);
	printf"z_down[%d,%d,%d] :=\t%f;\n",i,j,f,opt_z_down[i,j,f]> (sol_name);
}
for {i in F, j in F, x in V, y in V:(x,y) in E and i<>j}
{
	printf"y1t[%d,%d,%d,%d] :=\t%f;\n",i,j,x,y,opt_y1t[i,j,x,y]> (sol_name);
	printf"y1o1[%d,%d,%d,%d] :=\t%f;\n",i,j,x,y,opt_y1o1[i,j,x,y]> (sol_name);
	printf"y1o2[%d,%d,%d,%d] :=\t%f;\n",i,j,x,y,opt_y1o2[i,j,x,y]> (sol_name);

	printf"y2t[%d,%d,%d,%d] :=\t%f;\n",i,j,x,y,opt_y2t[i,j,x,y]> (sol_name);
	printf"y2o1[%d,%d,%d,%d] :=\t%f;\n",i,j,x,y,opt_y2o1[i,j,x,y]> (sol_name);
	printf"y2o2[%d,%d,%d,%d] :=\t%f;\n",i,j,x,y,opt_y2o2[i,j,x,y]> (sol_name);
}
for {i in F, j in F, x in V, x1 in V, x2 in V: (x1,x) in E and (x2,x) in E and i<>j and x1<> x2}
{
	printf"ym[%d,%d,%d,%d,%d] :=\t%f;\n",i,j,x,x1,x2,opt_ym[i,j,x,x1,x2]> (sol_name);
	printf"ymo1[%d,%d,%d,%d,%d] :=\t%f;\n",i,j,x,x1,x2,opt_ymo1[i,j,x,x1,x2]> (sol_name);
	printf"ymo2[%d,%d,%d,%d,%d] :=\t%f;\n",i,j,x,x1,x2,opt_ymo2[i,j,x,x1,x2]> (sol_name);
}
for {i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x2,x) in E and  i<>j and x1<> x2}
{
	printf"yd[%d,%d,%d,%d,%d] :=\t%f;\n",i,j,x,x1,x2,opt_yd[i,j,x,x1,x2]> (sol_name);
	printf"ydo1[%d,%d,%d,%d,%d] :=\t%f;\n",i,j,x,x1,x2,opt_ydo1[i,j,x,x1,x2]> (sol_name);
	printf"ydo2[%d,%d,%d,%d,%d] :=\t%f;\n",i,j,x,x1,x2,opt_ydo2[i,j,x,x1,x2]> (sol_name);
}
for {i in F, j in F, x in V, x1 in V, x2 in V: (x,x1) in E and (x,x2) in E and  i<>j and x1<> x2}
{
	printf"ys[%d,%d,%d,%d,%d] :=\t%f;\n",i,j,x,x1,x2,opt_ys[i,j,x,x1,x2]> (sol_name);
	printf"yso1[%d,%d,%d,%d,%d] :=\t%f;\n",i,j,x,x1,x2,opt_yso1[i,j,x,x1,x2]> (sol_name);
	printf"yso2[%d,%d,%d,%d,%d] :=\t%f;\n",i,j,x,x1,x2,opt_yso2[i,j,x,x1,x2]> (sol_name);
}

