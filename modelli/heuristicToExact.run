reset;
#to evaluate 
option presolve 0;

option solver gurobi;
option gurobi_options 'timing=1 outlev=1 threads=1 timelim=60';
param data_name symbolic;
let data_name :=sprintf("%s/data/nn%snf%s/%s.dat",($absPath),($nNodes),($nFlights),($datFile));
#let data_name :=sprintf("%s/data/nn10nf100/%s.dat",($absPath),($datFile));
param model_name symbolic;
let model_name :=sprintf("%s/multiComodity.mod",($absPath));
model (model_name);
data (data_name);
param iterations;
let iterations:=0;
param alpha;
let alpha:=4;
param found default 0;
param sol_name symbolic;
param nFixed default 3;
let sol_name := sprintf("%s/heuristicOut/nn%snf%s/%s/60%s.sol", ($absPath),($nNodes),($nFlights),($value),($datFile));
#let sol_name := sprintf("%s/heuristicOut/nn10nf100/%s%s.sol", ($absPath),($value),($datFile));
# Define the name of the file where the log of the solver will be saved
param log_name symbolic;
let log_name := sprintf("%s/heuristicOut/nn%snf%s/%s/60%s.log",($absPath),($nNodes),($nFlights),($value),($datFile));
#let log_name := sprintf("%s/heuristicOut/nn10nf100/%s%s.log",($absPath),($value),($datFile));
param result_name symbolic;
let result_name := sprintf("%s/results/%s_heurToExact%snf%s.csv",($absPath),($value),($nNodes),($nFlights));
param createDat symbolic;
let createDat := sprintf("%s/heurToExact/%s_heurToExact%s_%snf%s.dat",($absPath),($datFile),($value),($nNodes),($nFlights));

display data_name;
for {(i,j) in E}
	let dMCF[i,j]:= d[i,j];

param lastOpt default 0;
param sameOpt default 0;
#heuristic var
param opt default Infinity;

param opt_t_down{F,V} default Infinity;
param opt_t_up{F,V} default Infinity;

param opt_t_ear{F,V} default Infinity;															
param opt_t_lat{F,V} default Infinity;		

param opt_l{F,F,V} default Infinity;

param opt_w{(i,j) in E,F} default Infinity;		

param optTime default Infinity;
param iteropt default Infinity;
param obtainedSol binary default 0;
param t_hat_ear_backup{F,V} default Infinity;
param t_hat_lat_backup{F,V} default Infinity;

param tempNode default Infinity;

solve path >(log_name);
if solve_result <> "solved" then
{
	printf "path not found in given time\n";
       display solve_result, solve_result_num;
	break;
}
    # 
printf("fixing w\n");
	
let{(i,j) in E, f in F} w[i,j,f]:=wPath[i,j,f];
	
#if iterations > 0 then 
#{
for {f in F}
{
	let tempNode := s[f];
	repeat while (tempNode <> e[f])
	{
		for {(tempNode,i) in E : w[tempNode,i,f] == 1}
		{
			let t_hat_ear[f,i]:=t_hat_ear[f,tempNode] + d[tempNode,i]/v_min[f,tempNode,i];
			printf"%d,t_hat_ear[%d,%d]:=%f\t t_hat_ear_backup:=%f;\n",tempNode,f,i, t_hat_ear[f,i], t_hat_ear_backup[f,i];
			let t_hat_lat[f,i]:=t_hat_ear[f,i] + 2;
			let tempNode:=i;
			break;
		}
	}
}
solve conflicts > (log_name);
	
display solve_result, solve_result_num;
if (solve_result == "solved")
{
	printf "%s,%s,%s,60,%f,%f\n",($nNodes),($nFlights),($datFile),opt,(_ampl_elapsed_time + _total_solve_elapsed_time) >> (result_name);
	printf "### total_solve_time = %f\n\n",(_ampl_elapsed_time + _total_solve_elapsed_time) > (sol_name);
	display opt, iterations, optTime,iteropt>(sol_name);
	printf "variable\t\t value\n" >(sol_name);
	for {(i,j) in E, f in F}
    {
		printf "w[%d,%d,%d] :=\t %d;\n", i,j,f, opt_w[i,j,f] > (sol_name);
	}
	for {i in V,f in F}
	{
		printf"t_ear[%d,%d] :=\t%f;\n",f,i,opt_t_ear[f,i]> (sol_name);															
		printf"t_lat[%d,%d] :=\t%f;\n",f,i,opt_t_lat[f,i]> (sol_name);															
		printf"t_down[%d,%d] :=\t%f;\n",f,i, opt_t_down[f,i] > (sol_name);
		printf"t_up[%d,%d] :=\t%f;\n",f,i,opt_t_up[f,i]> (sol_name);
	}
	for {i in F, j in F, x in V: i<j and (sum{(x,x1) in E} w[x,x1,i] + sum{(x1,x) in E} w[x1,x,i] >= 1) and (sum{(x,x1) in E} w[x,x1,j] + sum{(x1,x) in E} w[x1,x,j] >= 1)}
	{
		printf"l[%d,%d,%d] :=\t%f;\n",i,j,x,opt_l[i,j,x]> (sol_name);
	}
}
else if (400<=solve_result_num and solve_result_num<=405) then
{
    #print the data
    printf "param nn:=%d;\nset F:=\n",($nNodes) > (createDat);
    for {f in F}
        printf "%d\n",f > (createDat);
    printf ";\nparam: E: d:=\n" > (createDat);
    for {(i,j) in E}
        printf "%d %d %f\n",i,j,d[i,j] > (createDat);
    #starting and ending points
    printf ";\nparam s:=\n" > (createDat);
    for {f in F}
        printf "%d %d\n",f,s[f] > (createDat);
    printf ";\nparam e:=\n" > (createDat);
    for {f in F}
        printf "%d %d\n",f,e[f] > (createDat);
    #speed
    printf ";\nparam v_min:=\n" > (createDat);
    for {f in F}
        for {(i,j) in E}
            printf "%d %d %d %f\n",f,i,j,v_min[f,i,j] > (createDat);
    printf ";\nparam v_max:=\n" > (createDat);
    for {f in F}
        for {(i,j) in E}
            printf "%d %d %d %f\n",f,i,j,v_max[f,i,j] > (createDat);
    #angles
    printf ";\nparam angleM:=\n" > (createDat);
    for {x in V, (x1,x) in E, (x2,x) in E: x1<>x2}
        printf "%d %d %d %f\n",x,x1,x2,angleM[x,x1,x2] > (createDat);
    printf ";\nparam angleP:=\n" > (createDat);
    for {x in V, (x1,x) in E, (x2,x) in E: x1<>x2}
        printf "%d %d %d %f\n",x,x1,x2,angleP[x,x1,x2] > (createDat);
    printf ";\nparam anglePM:=\n" > (createDat);
    for {x in V, (x1,x) in E, (x2,x) in E: x1<>x2}
        printf "%d %d %d %f\n",x,x1,x2,angleM[x,x1,x2] > (createDat);
    printf ";\nparam D:= %d;\n",D > (createDat); 
    printf "param t_hat_ear:=\n",alpha > (createDat);
    for {f in F, i in V}
        printf "%d %d %f\n",f,i,t_hat_ear[f,i] > (createDat);
    printf ";\nparam t_hat_lat:=\n",alpha > (createDat);
    for {f in F, i in V}
        printf "%d %d %f\n",f,i,t_hat_lat[f,i] > (createDat);
    #find flight with max conflicts
    #TODO da controllare se esatto
    param maxConflicts{F} default 0;
    for{f in F}
    {
        for {f1 in F,x in V,(x1,x) in E, (x2,x) in E: f<>f1 and x1<>x2 and (w[x1,x,f]+w[x2,x,f1]==2 or w[x1,x,f1] + w[x2,x,f] == 2) and t_hat_ear[f,x] < t_hat_ear[f1,x] }
        {
            if merge3[f,f1,x,x1,x2].slack == 0 then
                let maxConflicts[f]:=maxConflicts[f]+1;
            if merge4[f,f1,x,x1,x2].slack == 0 then
                let maxConflicts[f]:=maxConflicts[f]+1;
        }
        for {f1 in F,x in V,(x,x1) in E, (x2,x) in E: f<>f1 and x1<>x2 and (w[x,x1,f] + w[x2,x,f1]==2 or w[x,x1,f1]+w[x2,x,f] == 2) and t_hat_ear[f,x] < t_hat_ear[f1,x]}
        {
            if diver3[f,f1,x,x1,x2].slack == 0 then
                let maxConflicts[f]:=maxConflicts[f]+1;
            if diver4[f,f1,x,x1,x2].slack == 0 then
                let maxConflicts[f]:=maxConflicts[f]+1;
        }
        for { f1 in F,x in V,(x,x1) in E, (x,x2) in E: f<>f1 and x1<>x2 and (w[x,x1,f]+w[x,x2,f1]==2 or w[x,x1,f1] + w[x,x2,f] == 2) and t_hat_ear[f,x] < t_hat_ear[f1,x]}
        {
            if split3[f,f1,x,x1,x2].slack == 0 then
                let maxConflicts[f]:=maxConflicts[f]+1;
            if split4[f,f1,x,x1,x2].slack == 0 then
                let maxConflicts[f]:=maxConflicts[f]+1;
        }
    }
    set FreeFlights;
    for {i in 0..nFixed-1}
    {
        let FreeFlights:= FreeFlights union {t in F: maxConflicts[t] == max{f in F} maxConflicts[f]};
        let maxConflicts[FreeFlights[i]] := -1;
    }
    printf ";\nset fixedFlights:=\n" > (createDat);
    for {f in F diff FreeFlights}
        for {(i,j) in E: w[i,j,f] == 1}
        {
            printf "%d %d %d\n",f,i,j  > (createDat);
        }
    #fine TODO
    #print conflictsNodes
    printf ";\nset conflictsNodes:=\n" > (createDat);
    for {x in V, (x1,x) in E, (x2,x) in E: x1<>x2}
        printf "%d %d %d %f\n",x,x1,x2 > (createDat);
    printf ";" > (createDat);
    
    reset;
    param sol_name symbolic;
    let sol_name := sprintf("%s/heurToExact/nn%snf%s/%s/60%s.sol", ($absPath),($nNodes),($nFlights),($value),($datFile));
    #let sol_name := sprintf("%s/heuristicOut/nn10nf100/%s%s.sol", ($absPath),($value),($datFile));
    # Define the name of the file where the log of the solver will be saved
    param log_name symbolic;
    let log_name := sprintf("%s/heurToExact/nn%snf%s/%s/60%s.log",($absPath),($nNodes),($nFlights),($value),($datFile));
    #let log_name := sprintf("%s/heuristicOut/nn10nf100/%s%s.log",($absPath),($value),($datFile));
    param result_name symbolic;
    let result_name := sprintf("%s/results/%s_heurToExact%snf%s.csv",($absPath),($value),($nNodes),($nFlights));
    param createDat symbolic;
    let createDat := sprintf("%s/heurToExact/%s_heurToExact%s_%snf%s.dat",($absPath),($datFile),($value),($nNodes),($nFlights));
    param model_name symbolic;
    let model_name :=sprintf("%s/UAM_tactical.mod",($absPath));
    option gurobi_options 'timing=1 outlev=1 threads=1 timelim=431900';
    model (model_name);
    data (createDat);
    if drifted_flight == -1 then
    {
        drop driftEar;
        drop driftLat;
        drop driftWP;
    }
    solve > (log_name);
    printf "%s,%f,%f\n",($datFile),opt,(_ampl_elapsed_time + _total_solve_elapsed_time) >> (results_name);
    printf "\n### solve_result = %s, _total_solve_time = %f\n\n", solve_result, _total_solve_time > (log_name);
    # Store the solution in a file
    printf "### total_solve_time = %f\n\n",(_ampl_elapsed_time + _total_solve_elapsed_time) > (sol_name);
    display opt >(sol_name);
    printf "variable\t\t value\tLB\t\t\tUB \n" >(sol_name);
    for { j in 1.._nvars} 
    {
        printf "let %s :=\t %d\t %f\t %f;\n", _varname[j], _var[j] , _var[j].lb, _var[j].ub > (sol_name);
    }
}
else
{
    printf "conflicts not solved\n";
}
