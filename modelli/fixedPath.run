reset;
option solver gurobi;
option gurobi_options ('timing=1 outlev=1 threads=1 timelim=' &($timeLimit));
param data_name symbolic;
let data_name :=sprintf("%s/data/%s.dat",($absPath),($datFile));
#let data_name :=sprintf("%s/data/nn10nf100/%s.dat",($absPath),($datFile));
param model_name symbolic;
let model_name :=sprintf("%s/multiComodity.mod",($absPath));
model (model_name);
data (data_name);
param sol_name symbolic;
let sol_name := sprintf("%s/heuristicOut/fixed/nn%snf%s/%s.sol", ($absPath),($nNodes),($nFlights),($datFile));
#let sol_name := sprintf("%s/heuristicOut/nn10nf100/%s%s.sol", ($absPath),($value),($datFile));
# Define the name of the file where the log of the solver will be saved
param log_name symbolic;
let log_name := sprintf("%s/heuristicOut/fixed/nn%snf%s/%s.log", ($absPath),($nNodes),($nFlights),($datFile));
#let log_name := sprintf("%s/heuristicOut/nn10nf100/%s%s.log",($absPath),($value),($datFile));
display data_name;
for {i in V, j in V:(i,j) in E}
	let dMCF[i,j]:= d[i,j];

solve path >(log_name);
if solve_result <> "solved" then
{
	printf "path not found in given time\n";
	exit;
}
for {i in V,j in V,f in F: (i,j) in E}
	let w[i,j,f]:=wPath[i,j,f];
for {i in F, j in F, x in V, y in V:(x,y) in E and i<>j and w[x,y,i]+ w[x,y,j] == 2}
{
        let y1t[i,j,x,y]:=0;
        let y2t[i,j,x,y]:=0;
}
for {i in F, j in F, x in V, x1 in V, x2 in V : i<>j and x1<>x2}
{
    if ((x1,x) in E and (x2,x) in E and w[x1,x,i]+ w[x2,x,j] == 2) then
		let ym[i,j,x,x1,x2]:=0;
    if ((x,x1) in E and (x2,x) in E and w[x,x1,i]+w[x2,x,j] == 2) then
        let yd[i,j,x,x1,x2]:=0;
    if ((x,x1) in E and (x,x2) in E and w[x,x1,i]+w[x,x2,j] ==2) then
        let ys[i,j,x,x1,x2]:=0;
}	
printf "solve time:= %f, ampl time:= %f, sol:=%d\n",_solve_time,_ampl_time,MC >(sol_name);
solve conflicts > (log_name);
printf "nsolve time:= %f, ampl time:= %f, sol:=%d\n",_solve_time,_ampl_time,UAM >(sol_name);

# Store the solution in a file
printf "%s,%s,%s,fixed_instance,%d,%f\n",($nNodes),($nFlights),($datFile),UAM,(_ampl_elapsed_time + _total_solve_elapsed_time) >> "resultsFixed.csv";
printf "### total_solve_time = %f\n\n",(_ampl_elapsed_time + _total_solve_elapsed_time) > (sol_name);
display UAM >(sol_name);
printf "variable\t\t value\t LB\t\t\t UB\n" >(sol_name);
for { j in 1.._nvars} {
   printf "let %s :=\t %d\t %f\t %f;\n", _varname[j], _var[j] , _var[j].lb, _var[j].ub > (sol_name);
}


